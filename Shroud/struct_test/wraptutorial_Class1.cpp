// wraptutorial_Class1.cpp
// This file is generated by Shroud 0.12.1. Do not edit.
#include "wraptutorial_Class1.h"
#include <cstddef>
#include "tutorial.hpp"

// splicer begin namespace.tutorial.class.Class1.CXX_definitions
// splicer end namespace.tutorial.class.Class1.CXX_definitions

extern "C" {

// splicer begin namespace.tutorial.class.Class1.C_definitions
// splicer end namespace.tutorial.class.Class1.C_definitions

TUT_tutorial_Class1 * TUT_tutorial_Class1_new_0(int test1, double test2,
    bool TorF, TUT_tutorial_Class1 * SHC_rv)
{
    // splicer begin namespace.tutorial.class.Class1.method.new_0
    tutorial::Class1 *SHCXX_rv = new tutorial::Class1(test1, test2,
        TorF);
    SHC_rv->addr = static_cast<void *>(SHCXX_rv);
    SHC_rv->idtor = 1;
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.new_0
}

TUT_tutorial_Class1 * TUT_tutorial_Class1_new_1(int test1, double test2,
    bool TorF, int o_test, TUT_tutorial_Class1 * SHC_rv)
{
    // splicer begin namespace.tutorial.class.Class1.method.new_1
    tutorial::Class1 *SHCXX_rv = new tutorial::Class1(test1, test2,
        TorF, o_test);
    SHC_rv->addr = static_cast<void *>(SHCXX_rv);
    SHC_rv->idtor = 1;
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.new_1
}

TUT_tutorial_Class1 * TUT_tutorial_Class1_new_2(int test1, double test2,
    bool TorF, int o_test, double o_test2, TUT_tutorial_Class1 * SHC_rv)
{
    // splicer begin namespace.tutorial.class.Class1.method.new_2
    tutorial::Class1 *SHCXX_rv = new tutorial::Class1(test1, test2,
        TorF, o_test, o_test2);
    SHC_rv->addr = static_cast<void *>(SHCXX_rv);
    SHC_rv->idtor = 1;
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.new_2
}

TUT_tutorial_Class1 * TUT_tutorial_Class1_new_3(int test1, double test2,
    bool TorF, int o_test, double o_test2, bool o_TorF,
    TUT_tutorial_Class1 * SHC_rv)
{
    // splicer begin namespace.tutorial.class.Class1.method.new_3
    tutorial::Class1 *SHCXX_rv = new tutorial::Class1(test1, test2,
        TorF, o_test, o_test2, o_TorF);
    SHC_rv->addr = static_cast<void *>(SHCXX_rv);
    SHC_rv->idtor = 1;
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.new_3
}

void TUT_tutorial_Class1_delete(TUT_tutorial_Class1 * self)
{
    tutorial::Class1 *SH_this =
        static_cast<tutorial::Class1 *>(self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.delete
    delete SH_this;
    self->addr = nullptr;
    // splicer end namespace.tutorial.class.Class1.method.delete
}

void TUT_tutorial_Class1_receive_str(TUT_tutorial_Class1 * self,
    TUT_str1 * arg)
{
    tutorial::Class1 *SH_this =
        static_cast<tutorial::Class1 *>(self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.receive_str
    tutorial::str1 * SHCXX_arg = static_cast<tutorial::str1 *>
        (static_cast<void *>(arg));
    SH_this->receive_str(SHCXX_arg);
    // splicer end namespace.tutorial.class.Class1.method.receive_str
}

void TUT_tutorial_Class1_test_struct(TUT_tutorial_Class1 * self)
{
    tutorial::Class1 *SH_this =
        static_cast<tutorial::Class1 *>(self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.test_struct
    SH_this->test_struct();
    // splicer end namespace.tutorial.class.Class1.method.test_struct
}

}  // extern "C"
