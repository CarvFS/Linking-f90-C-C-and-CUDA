// wraptutorial_Class1.cpp
// This file is generated by Shroud 0.12.2. Do not edit.

#include "tutorial.hpp"
#include <string>
#include <cstddef>
#include "wraptutorial_Class1.h"

// splicer begin namespace.tutorial.class.Class1.CXX_definitions
// splicer end namespace.tutorial.class.Class1.CXX_definitions

extern "C" {

// splicer begin namespace.tutorial.class.Class1.C_definitions
// splicer end namespace.tutorial.class.Class1.C_definitions

TUT_tutorial_Class1 * TUT_tutorial_Class1_new(
    TUT_tutorial_Class1 * SHC_rv)
{
    // splicer begin namespace.tutorial.class.Class1.method.new
    tutorial::Class1 *SHCXX_rv = new tutorial::Class1();
    SHC_rv->addr = static_cast<void *>(SHCXX_rv);
    SHC_rv->idtor = 1;
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.new
}

void TUT_tutorial_Class1_set_strings(TUT_tutorial_Class1 * self,
    int char_len)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.set_strings
    SH_this->set_strings(char_len);
    // splicer end namespace.tutorial.class.Class1.method.set_strings
}

void TUT_tutorial_Class1_printvalues(TUT_tutorial_Class1 * self)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.printvalues
    SH_this->printvalues();
    // splicer end namespace.tutorial.class.Class1.method.printvalues
}

int * TUT_tutorial_Class1_get_int_ptr(TUT_tutorial_Class1 * self,
    int * len)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_int_ptr
    int * SHC_rv = SH_this->get_int_ptr(len);
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.get_int_ptr
}

void TUT_tutorial_Class1_get_int_ptr_bufferify(
    TUT_tutorial_Class1 * self, TUT_SHROUD_array *SHT_rv_cdesc)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_int_ptr_bufferify
    int len;
    int * SHC_rv = SH_this->get_int_ptr(&len);
    SHT_rv_cdesc->cxx.addr  = SHC_rv;
    SHT_rv_cdesc->cxx.idtor = 0;
    SHT_rv_cdesc->addr.base = SHC_rv;
    SHT_rv_cdesc->type = SH_TYPE_INT;
    SHT_rv_cdesc->elem_len = sizeof(int);
    SHT_rv_cdesc->rank = 1;
    SHT_rv_cdesc->shape[0] = len;
    SHT_rv_cdesc->size = SHT_rv_cdesc->shape[0];
    // splicer end namespace.tutorial.class.Class1.method.get_int_ptr_bufferify
}

#if 0
! Not Implemented
void TUT_tutorial_Class1_get_strs2(TUT_tutorial_Class1 * self,
    char * * strs, int * name_len)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_strs2
    SH_this->get_strs2(strs, name_len);
    // splicer end namespace.tutorial.class.Class1.method.get_strs2
}
#endif

void TUT_tutorial_Class1_get_strs2_bufferify(TUT_tutorial_Class1 * self,
    TUT_SHROUD_array *SHT_strs_cdesc)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_strs2_bufferify
    std::string *strs;
    int name_len;
    SH_this->get_strs2(&strs, &name_len);
    TUT_ShroudArrayStringOut(SHT_strs_cdesc, strs, name_len);
    // splicer end namespace.tutorial.class.Class1.method.get_strs2_bufferify
}

void TUT_tutorial_Class1_delete(TUT_tutorial_Class1 * self)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.delete
    delete SH_this;
    self->addr = nullptr;
    // splicer end namespace.tutorial.class.Class1.method.delete
}

}  // extern "C"
