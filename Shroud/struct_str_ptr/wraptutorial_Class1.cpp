// wraptutorial_Class1.cpp
// This file is generated by Shroud 0.12.2. Do not edit.

#include "tutorial.hpp"
#include <string>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include "wraptutorial_Class1.h"

// splicer begin namespace.tutorial.class.Class1.CXX_definitions
// splicer end namespace.tutorial.class.Class1.CXX_definitions

extern "C" {


// helper ShroudLenTrim
// Returns the length of character string src with length nsrc,
// ignoring any trailing blanks.
static int ShroudLenTrim(const char *src, int nsrc) {
    int i;

    for (i = nsrc - 1; i >= 0; i--) {
        if (src[i] != ' ') {
            break;
        }
    }

    return i + 1;
}


// helper ShroudStrArrayAlloc
// Copy src into new memory and null terminate.
// char **src +size(nsrc) +len(len)
// CHARACTER(len) src(nsrc)
static char **ShroudStrArrayAlloc(const char *src, int nsrc, int len)
{
   char **rv = static_cast<char **>(std::malloc(sizeof(char *) * nsrc));
   const char *src0 = src;
   for(int i=0; i < nsrc; ++i) {
      int ntrim = ShroudLenTrim(src0, len);
      char *tgt = static_cast<char *>(std::malloc(ntrim+1));
      std::memcpy(tgt, src0, ntrim);
      tgt[ntrim] = '\0';
      rv[i] = tgt;
      src0 += len;
   }
   return rv;
}

// helper ShroudStrArrayFree
// Release memory allocated by ShroudStrArrayAlloc
static void ShroudStrArrayFree(char **src, int nsrc)
{
   for(int i=0; i < nsrc; ++i) {
       std::free(src[i]);
   }
   std::free(src);
}
// splicer begin namespace.tutorial.class.Class1.C_definitions
// splicer end namespace.tutorial.class.Class1.C_definitions

TUT_tutorial_Class1 * TUT_tutorial_Class1_new(
    TUT_tutorial_Class1 * SHC_rv)
{
    // splicer begin namespace.tutorial.class.Class1.method.new
    tutorial::Class1 *SHCXX_rv = new tutorial::Class1();
    SHC_rv->addr = static_cast<void *>(SHCXX_rv);
    SHC_rv->idtor = 1;
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.new
}

void TUT_tutorial_Class1_set_strings(TUT_tutorial_Class1 * self,
    char **names)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.set_strings
    SH_this->set_strings(names);
    // splicer end namespace.tutorial.class.Class1.method.set_strings
}

void TUT_tutorial_Class1_set_strings_bufferify(
    TUT_tutorial_Class1 * self, const char *names,
    size_t SHT_names_size, int SHT_names_len)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.set_strings_bufferify
    char **SHCXX_names = ShroudStrArrayAlloc(names, SHT_names_size,
        SHT_names_len);
    SH_this->set_strings(SHCXX_names);
    ShroudStrArrayFree(SHCXX_names, SHT_names_size);
    // splicer end namespace.tutorial.class.Class1.method.set_strings_bufferify
}

void TUT_tutorial_Class1_printvalues(TUT_tutorial_Class1 * self)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.printvalues
    SH_this->printvalues();
    // splicer end namespace.tutorial.class.Class1.method.printvalues
}

int * TUT_tutorial_Class1_get_int_ptr(TUT_tutorial_Class1 * self,
    int * len)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_int_ptr
    int * SHC_rv = SH_this->get_int_ptr(len);
    return SHC_rv;
    // splicer end namespace.tutorial.class.Class1.method.get_int_ptr
}

void TUT_tutorial_Class1_get_int_ptr_bufferify(
    TUT_tutorial_Class1 * self, TUT_SHROUD_array *SHT_rv_cdesc)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_int_ptr_bufferify
    int len;
    int * SHC_rv = SH_this->get_int_ptr(&len);
    SHT_rv_cdesc->cxx.addr  = SHC_rv;
    SHT_rv_cdesc->cxx.idtor = 0;
    SHT_rv_cdesc->addr.base = SHC_rv;
    SHT_rv_cdesc->type = SH_TYPE_INT;
    SHT_rv_cdesc->elem_len = sizeof(int);
    SHT_rv_cdesc->rank = 1;
    SHT_rv_cdesc->shape[0] = len;
    SHT_rv_cdesc->size = SHT_rv_cdesc->shape[0];
    // splicer end namespace.tutorial.class.Class1.method.get_int_ptr_bufferify
}

#if 0
! Not Implemented
void TUT_tutorial_Class1_get_strs2(TUT_tutorial_Class1 * self,
    char * * strs, int * name_len)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_strs2
    SH_this->get_strs2(strs, name_len);
    // splicer end namespace.tutorial.class.Class1.method.get_strs2
}
#endif

void TUT_tutorial_Class1_get_strs2_bufferify(TUT_tutorial_Class1 * self,
    TUT_SHROUD_array *SHT_strs_cdesc)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.get_strs2_bufferify
    std::string *strs;
    int name_len;
    SH_this->get_strs2(&strs, &name_len);
    TUT_ShroudArrayStringOut(SHT_strs_cdesc, strs, name_len);
    // splicer end namespace.tutorial.class.Class1.method.get_strs2_bufferify
}

void TUT_tutorial_Class1_delete(TUT_tutorial_Class1 * self)
{
    tutorial::Class1 *SH_this = static_cast<tutorial::Class1 *>
        (self->addr);
    // splicer begin namespace.tutorial.class.Class1.method.delete
    delete SH_this;
    self->addr = nullptr;
    // splicer end namespace.tutorial.class.Class1.method.delete
}

}  // extern "C"
